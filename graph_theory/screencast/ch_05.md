**Дерево** - простой связный граф без циклов. Если имеется простой граф без циклов, не обязательно связный, то такой граф называется **лесом**, и любая компонента связности является деревом.  

Свойства деревьев:  
**Лист** в графе - любая вершина степень которой = 1. 
Концы любого пути являются листьями.  

**У любого дерева, построенного на n-вершинах имеется ровно n - 1 ребро**.  

Верно и обратное утверждение - если имеется граф на n-вершинах с n - 1 ребрами, то этот граф является деревом.  

Основная характеризация моста - мост это ребро, которое не принадлежит ни одному из циклов графа G.

Если имеется какой-то цикл в графе, то любое ребро, принадлежащее этому циклу не является мостом. Т.е. удаление такого ребра не приводит к потери связности графа.  

В любом связном графе на n-вершинах имеется остовное дерево.  

**Алгоритм поиска в глубину**.  

![img_1](https://user-images.githubusercontent.com/35499834/45920345-140ad100-bea3-11e8-96f0-326952f0e4c5.png)

Предположим у нас есть связный граф на n-вершинах и все вершины окрашены в синий цвет. Выберем произвольную вершину(1) и окрасим ее в красный цвет. Дальше перебираем смежные с этой вершиной вершины и будем искать среди них первую вершину окрашенную в синий цвет(2). Далее окрасим ребро, соединяющее эти две вершины в красный цвет и рекурсивно запустим алгоритм с вершины 2. Так действуем до тех пор, пока все вершины не окрасятся в красный цвет. Вместе с вершинами окрасятся и n - 1 ребро. Красным получится связанный граф, а раз n - вершин и n - 1 ребер то он является деревом и является остовным деревом исходного графа.  

Связный граф G является деревом тогда и только тогда, когда любое его ребро является мостом. 

Если у нас имеется дерево, то в дереве циклы отсутствуют(из определения дерева), следовательно любое из его ребер не принадлежит никакому циклу и т.е. является мостом.  

Если в связном графе любое ребро является мостом, следовательно оно не принадлежит никакому циклу, следовательно циклы вообще отсутствуют, а т.к. это связный граф без циклов то это дерево.  

Граф G является деревом тогда и только тогда, когда любые две вершины этого графа соединены между собой единственным путем.

**Корневое дерево**
![img_2](https://user-images.githubusercontent.com/35499834/45920629-49192280-bea7-11e8-9979-9a97a5c59cf2.png)

![img_3](https://user-images.githubusercontent.com/35499834/45920631-59c99880-bea7-11e8-9372-54a9af1caf61.png)

Имеется единственный путь между корневой вершиной и любой другой вершиной в дереве. И вот длина этого пути определяет уровень соответствующей вершины в корневом дереве. (вершина 6 имеет нулевой уровень, 5,7,8 - на первом уровне и т.д.)  

Максимальный уровень в таком корневом дереве называется **высотой этого дерева**

Для направленных деревьев например вершина 5 является родителем для вершины 4. Вершина 5 для вершины 1 является предком а наоборот - потомком.  Корневая вершина также называется **истоком**. 

??? частично-упорядоченное множество. аксиома антисимметричности.  

Какая вершина ближе к корню, та и меньше(если уровни различны). Сравниваются только те вершины которые лежат на общем пути.
Несравнимые между собой вершины - 1 и 8(они не лежат не на каком-то общем пути)  

Нормальное дерево - 

**Алгоритм поиска в ширину**  
Поместим в начало очереди нашу корневую вершину(6). Далее из очереди вынимается эта вершина и смотрим на смежные с этой вершиной вершины и если эти вершины еще не окрашены в красный цвет, то они помещаются в очередь. Потом берется из очереди вершина и смотрим на смежные с ней вершины которые также еще неокрашены. Находим(4) и помещаем в конец очереди.  

В результате этого алгоритма построим остовное дерево обладающее свойством: расстояние между вершинами в этом графе совпадает с расстоянием между вершиной 6(корневой вершиной) и всеми остальными вершинами в исходном графе.   